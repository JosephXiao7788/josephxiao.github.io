<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>轨道工程师：点火与升空</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0f172a;
            color: #e2e8f0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #1e293b;
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-text {
            font-family: 'Courier New', Courier, monospace;
            text-shadow: 1px 1px 0 #000;
        }

        #status-bar {
            background: rgba(15, 23, 42, 0.8);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #334155;
            display: inline-block;
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            text-align: center;
        }

        h1 { margin: 0 0 20px 0; color: #38bdf8; text-transform: uppercase; letter-spacing: 2px; }
        p { max-width: 600px; line-height: 1.6; color: #94a3b8; margin-bottom: 30px; }
        
        button {
            background: #0ea5e9;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            font-family: inherit;
        }

        button:hover { background: #0284c7; transform: scale(1.05); }
        button:active { transform: scale(0.95); }

        .hidden { display: none !important; }

        .text-cyan { color: #22d3ee; }
        .text-orange { color: #fb923c; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div id="top-hud">
            <div id="status-bar" class="hud-text">
                <span id="stage-text">系统状态: 待机</span>
                <span style="margin: 0 15px;">|</span>
                <span id="info-text">等待指令...</span>
            </div>
        </div>
        
        <div id="bottom-hud" class="hud-text hidden">
            <div style="display: flex; gap: 20px; align-items: flex-end;">
                <div>
                    <div>燃料 (FUEL)</div>
                    <div style="width: 200px; height: 10px; background: #334155; margin-top: 5px;">
                        <div id="fuel-bar" style="width: 100%; height: 100%; background: #22c55e;"></div>
                    </div>
                </div>
                <div>
                    <div>高度 (ALT)</div>
                    <span id="altitude-text" class="text-cyan">0 m</span>
                </div>
                <div>
                    <div>速度 (VEL)</div>
                    <span id="velocity-text" class="text-orange">0 m/s</span>
                </div>
            </div>
        </div>
    </div>

    <div id="message-overlay">
        <h1 id="msg-title">轨道工程师 v1.1</h1>
        <p id="msg-desc">
            航电系统已升级。姿态阻尼已加强。<br>
            <br>
            <strong>操作建议</strong>：<br>
            1. 保持火箭完全垂直（0°），减少余弦损失。<br>
            2. 不要过度修正，轻点左右两侧调整姿态。<br>
            3. 燃料耗尽前必须达到 10,000 米。
        </p>
        <button id="action-btn">开始任务</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiStageText = document.getElementById('stage-text');
const uiInfoText = document.getElementById('info-text');
const overlay = document.getElementById('message-overlay');
const msgTitle = document.getElementById('msg-title');
const msgDesc = document.getElementById('msg-desc');
const actionBtn = document.getElementById('action-btn');
const bottomHud = document.getElementById('bottom-hud');
const fuelBar = document.getElementById('fuel-bar');
const altText = document.getElementById('altitude-text');
const velText = document.getElementById('velocity-text');

const STATE = { MENU: 0, CIRCUIT: 1, COUNTDOWN: 2, LAUNCH: 3, GAMEOVER: 4 };
let currentState = STATE.MENU;
let frameId = null;
let lastTime = 0;

const keys = { Space: false, ArrowLeft: false, ArrowRight: false };
let isPointerDown = false;
let pointerX = 0;

window.addEventListener('keydown', (e) => {
    if (["Space", "ArrowLeft", "ArrowRight"].includes(e.code)) e.preventDefault();
    if (e.code === 'Space') keys.Space = true;
    if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
    if (e.code === 'ArrowRight') keys.ArrowRight = true;
});

window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') keys.Space = false;
    if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
    if (e.code === 'ArrowRight') keys.ArrowRight = false;
});

function handleInputStart(e) {
    if (currentState === STATE.LAUNCH) {
        isPointerDown = true;
        updatePointerPos(e);
        if(e.type.startsWith('touch')) e.preventDefault(); 
    }
    handleMouseClick(e);
}

function handleInputEnd(e) { isPointerDown = false; }
function handleInputMove(e) {
    if (isPointerDown) {
        updatePointerPos(e);
        if(e.type.startsWith('touch')) e.preventDefault();
    }
}

function updatePointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    pointerX = clientX - rect.left;
}

canvas.addEventListener('mousedown', handleInputStart);
window.addEventListener('mouseup', handleInputEnd);
canvas.addEventListener('mousemove', handleInputMove);
canvas.addEventListener('touchstart', handleInputStart, {passive: false});
window.addEventListener('touchend', handleInputEnd);
canvas.addEventListener('touchmove', handleInputMove, {passive: false});

// --- Phase 1: Circuit ---
const GRID_SIZE = 6;
const TILE_SIZE = 80;
const OFFSET_X = (800 - (GRID_SIZE * TILE_SIZE)) / 2;
const OFFSET_Y = (600 - (GRID_SIZE * TILE_SIZE)) / 2;
let circuitGrid = [];
let isCircuitSolved = false;

function initCircuit() {
    isCircuitSolved = false;
    circuitGrid = [];
    for(let y=0; y<GRID_SIZE; y++) {
        let row = [];
        for(let x=0; x<GRID_SIZE; x++) {
            let type = Math.random() > 0.7 ? 2 : 1; 
            row.push({ x: x, y: y, type: type, rotation: Math.floor(Math.random() * 4), powered: false });
        }
        circuitGrid.push(row);
    }
    circuitGrid[0][0] = { x:0, y:0, type: 10, rotation: 0, powered: true };
    circuitGrid[GRID_SIZE-1][GRID_SIZE-1] = { x:GRID_SIZE-1, y:GRID_SIZE-1, type: 11, rotation: 0, powered: false };
    checkCircuitConnectivity();
}

function handleMouseClick(e) {
    if (currentState !== STATE.CIRCUIT) return;
    let clientX = e.touches ? e.touches[0].clientX : e.clientX;
    let clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left;
    const my = clientY - rect.top;

    if (mx >= OFFSET_X && mx <= OFFSET_X + GRID_SIZE * TILE_SIZE &&
        my >= OFFSET_Y && my <= OFFSET_Y + GRID_SIZE * TILE_SIZE) {
        const gx = Math.floor((mx - OFFSET_X) / TILE_SIZE);
        const gy = Math.floor((my - OFFSET_Y) / TILE_SIZE);
        const tile = circuitGrid[gy][gx];
        if (tile.type !== 10 && tile.type !== 11) {
            tile.rotation = (tile.rotation + 1) % 4;
            checkCircuitConnectivity();
            if (isCircuitSolved) setTimeout(startCountdown, 500);
        }
    }
}

function checkCircuitConnectivity() {
    circuitGrid.forEach(row => row.forEach(t => t.powered = false));
    let startNode = circuitGrid[0][0];
    startNode.powered = true;
    let queue = [startNode];
    let visited = new Set(['0,0']);
    isCircuitSolved = false;

    while(queue.length > 0) {
        let curr = queue.shift();
        const dirs = [{ dx: 0, dy: -1, s: 0 }, { dx: 1, dy: 0, s: 1 }, { dx: 0, dy: 1, s: 2 }, { dx: -1, dy: 0, s: 3 }];
        for (let d of dirs) {
            let nx = curr.x + d.dx, ny = curr.y + d.dy;
            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                let neighbor = circuitGrid[ny][nx];
                if (!visited.has(`${nx},${ny}`)) {
                    if (canConnect(curr, d.s) && canConnect(neighbor, (d.s + 2) % 4)) {
                        neighbor.powered = true;
                        visited.add(`${nx},${ny}`);
                        queue.push(neighbor);
                        if (neighbor.type === 11) isCircuitSolved = true;
                    }
                }
            }
        }
    }
}

function canConnect(tile, side) {
    let b = (side - tile.rotation + 4) % 4;
    if (tile.type >= 10) return true;
    if (tile.type === 1) return b === 1 || b === 3;
    if (tile.type === 2) return b === 3 || b === 2;
    return false;
}

function drawCircuit() {
    ctx.fillStyle = '#1e293b';
    ctx.fillRect(0,0, canvas.width, canvas.height);
    ctx.textAlign = "center";
    ctx.fillStyle = "#94a3b8";
    ctx.font = "20px monospace";
    ctx.fillText("任务 1: 连接点火电路", canvas.width/2, 50);

    for(let y=0; y<GRID_SIZE; y++) {
        for(let x=0; x<GRID_SIZE; x++) {
            let tile = circuitGrid[y][x];
            let px = OFFSET_X + x * TILE_SIZE, py = OFFSET_Y + y * TILE_SIZE;
            ctx.strokeStyle = '#334155';
            ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
            ctx.save();
            ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2);
            ctx.rotate(tile.rotation * Math.PI / 2);
            ctx.strokeStyle = tile.powered ? '#fbbf24' : '#475569';
            ctx.lineWidth = 8;
            ctx.beginPath();
            if (tile.type === 1) { ctx.moveTo(-30, 0); ctx.lineTo(30, 0); }
            else if (tile.type === 2) { ctx.moveTo(-30, 0); ctx.lineTo(0,0); ctx.lineTo(0, 30); }
            else if (tile.type === 10) { ctx.fillStyle = '#ef4444'; ctx.fillRect(-20, -20, 40, 40); }
            else if (tile.type === 11) { ctx.fillStyle = tile.powered ? '#22c55e' : '#64748b'; ctx.arc(0,0, 20, 0, Math.PI*2); ctx.fill(); }
            ctx.stroke();
            ctx.restore();
        }
    }
}

// --- Phase 2: Launch ---
let rocket = { y: 0, vy: 0, angle: 0, va: 0, fuel: 100, x: 400 };
const GRAVITY = 9.8, THRUST = 26, ROT_SPEED = 2.5, SCALE = 10;
let particles = [];

function updatePhysics(dt) {
    const inputThrust = (keys.Space || isPointerDown);
    const inputLeft = keys.ArrowLeft || (isPointerDown && pointerX < 300);
    const inputRight = keys.ArrowRight || (isPointerDown && pointerX > 500);

    let thrustForce = 0;
    if (inputThrust && rocket.fuel > 0) {
        thrustForce = THRUST;
        rocket.fuel -= 12 * dt; // 稍微降低了燃料消耗率
        for(let i=0; i<3; i++) particles.push({ x: rocket.x, y: 440, vx: (Math.random()-0.5)*4, vy: 5+Math.random()*5, life: 1 });
    }

    if (inputLeft) rocket.va -= ROT_SPEED * dt;
    if (inputRight) rocket.va += ROT_SPEED * dt;
    
    // 增加自动纠偏阻尼，帮助玩家保持垂直
    rocket.va *= 0.92; 
    rocket.angle += rocket.va;

    if (Math.abs(rocket.angle) > 55 && rocket.y > 50) return endGame(false, "姿态倾角过大，导致结构解体！");

    let rad = rocket.angle * Math.PI / 180;
    let ay = (thrustForce * Math.cos(rad)) - GRAVITY;
    let ax = (thrustForce * Math.sin(rad));

    rocket.vy += ay * dt;
    rocket.x += ax * dt * 10;
    rocket.y += rocket.vy * dt * SCALE;

    if (rocket.y < 0) { rocket.y = 0; if (rocket.vy < -20) return endGame(false, "坠毁在发射台！"); rocket.vy = 0; }
    if (rocket.y > 10000) return endGame(true, "任务成功！入轨达成。");

    fuelBar.style.width = Math.max(0, rocket.fuel) + "%";
    altText.textContent = Math.floor(rocket.y) + " m";
    velText.textContent = Math.floor(rocket.vy*10)/10 + " m/s";
    particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= dt*2; if(p.life <= 0) particles.splice(i,1); });
}

function drawLaunch() {
    let b = Math.max(0, 40 - rocket.y / 250);
    ctx.fillStyle = `rgb(${b}, ${b*1.2}, ${b*1.8 + 15})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(rocket.x, 400);
    ctx.rotate(rocket.angle * Math.PI / 180);
    ctx.fillStyle = "#e2e8f0";
    ctx.beginPath(); ctx.ellipse(0, 0, 12, 50, 0, 0, Math.PI*2); ctx.fill(); // Rocket body
    ctx.fillStyle = "#ef4444";
    ctx.beginPath(); ctx.moveTo(-12, 30); ctx.lineTo(-20, 50); ctx.lineTo(-10, 45); ctx.fill();
    ctx.beginPath(); ctx.moveTo(12, 30); ctx.lineTo(20, 50); ctx.lineTo(10, 45); ctx.fill();
    ctx.restore();

    particles.forEach(p => { ctx.fillStyle = `rgba(255,100,0,${p.life})`; ctx.beginPath(); ctx.arc(p.x, p.y, 3+p.life*5, 0, Math.PI*2); ctx.fill(); });
}

function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    if (currentState === STATE.CIRCUIT) drawCircuit();
    else if (currentState === STATE.LAUNCH) { updatePhysics(dt); drawLaunch(); }
    if (currentState !== STATE.GAMEOVER) frameId = requestAnimationFrame(gameLoop);
}

function startGame() { overlay.classList.add('hidden'); currentState = STATE.CIRCUIT; initCircuit(); requestAnimationFrame(gameLoop); }
function startCountdown() {
    currentState = STATE.COUNTDOWN;
    let c = 3;
    const timer = setInterval(() => {
        ctx.fillStyle = "#1e293b"; ctx.fillRect(0,0,800,600);
        ctx.fillStyle = "#38bdf8"; ctx.font = "100px Arial"; ctx.textAlign="center";
        ctx.fillText(c, 400, 300);
        c--;
        if (c < 0) { clearInterval(timer); currentState = STATE.LAUNCH; rocket = { y: 0, vy: 0, angle: 0, va: 0, fuel: 100, x: 400 }; bottomHud.classList.remove('hidden'); }
    }, 800);
}

function endGame(s, m) {
    currentState = STATE.GAMEOVER;
    overlay.classList.remove('hidden');
    msgTitle.textContent = s ? "入轨成功" : "任务失败";
    msgTitle.style.color = s ? "#22c55e" : "#ef4444";
    msgDesc.innerHTML = `${m}<br>最终高度: ${Math.floor(rocket.y)} m`;
    actionBtn.onclick = () => location.reload();
}

actionBtn.addEventListener('click', startGame);
</script>
</body>
</html>
